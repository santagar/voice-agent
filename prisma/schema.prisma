generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

/// Status for user entities:
/// - active: can use the platform normally
/// - suspended: temporarily blocked (e.g. abuse, billing issues)
/// - disabled: permanently deactivated, kept only for audit/history
enum UserStatus {
  active
  suspended
  disabled
}

/// Status for workspaces:
/// - active: workspace is usable
/// - suspended: access temporarily blocked for all members
/// - disabled: archived / closed workspace, kept for history
enum WorkspaceStatus {
  active
  suspended
  disabled
}

/// Status for assistants and their templates:
/// - active: visible and callable in conversations
/// - archived: hidden from normal use but kept for history
/// - disabled: cannot be used (policy or technical reasons)
enum AssistantStatus {
  active
  archived
  disabled
}

/// Status for conversations:
/// - active: ongoing or recently active conversation
/// - closed: explicitly finished by the user or assistant
/// - archived: kept only in long-term history
enum ConversationStatus {
  active
  closed
  archived
}

/// Status for authentication accounts:
/// - active: account can be used to sign in
/// - suspended: temporarily blocked
/// - disabled: permanently revoked
enum AuthAccountStatus {
  active
  suspended
  disabled
}

/// Core user identity
model User {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt      @map("updated_at")
  email     String   @unique
  name      String?
  image     String?
  role      String   @default("user")
  status    UserStatus @default(active)

  settings     UserSettings?
  memberships  WorkspaceMember[]
  assistants   Assistant[]           @relation("AssistantOwner")
  conversations Conversation[]       @relation("ConversationUser")
  authAccounts AuthAccount[]         @relation("UserAuthAccounts")

  tools             Tool[]             @relation("ToolOwner")
  instructions      Instruction[]      @relation("InstructionOwner")
  sanitizationRules SanitizationRule[] @relation("SanitizationRuleOwner")

  @@map("users")
}

/// Per-user preferences (theme, locale, audio, debug flags, etc.)
model UserSettings {
  id               String   @id @default(uuid())
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt      @map("updated_at")
  userId           String   @unique @map("user_id")
  theme            String   @default("system")
  locale           String   @default("en")
  playbackRate     Float    @default(1.05) @map("playback_rate")
  voicePreferences Json?    @map("voice_preferences")
  debugPreferences Json?    @map("debug_preferences")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_settings")
}

/// Workspace / organization that groups assistants and conversations
model Workspace {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt      @map("updated_at")
  name      String
  slug      String   @unique
  status    WorkspaceStatus @default(active)

  members       WorkspaceMember[]
  assistants    Assistant[]

  @@map("workspaces")
}

/// Membership of a user in a workspace with a role
model WorkspaceMember {
  id          String   @id @default(uuid())
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt      @map("updated_at")
  role        String   @default("member")
  workspaceId String   @map("workspace_id")
  userId      String   @map("user_id")

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([workspaceId, userId], map: "workspace_user_unique")
  @@map("workspace_members")
}

/// Generic tool definition aligned with Realtime API tools.
/// - `type` matches Realtime tool type: "function", "code_interpreter", "file_search", etc.
/// - `kind` is app-specific routing: "business", "session", "system", etc.
/// - `definitionJson` stores the raw tool spec/config (e.g. function parameters, options).
model Tool {
  id            String   @id @default(uuid())
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt      @map("updated_at")

  name          String   @unique
  type          String   @default("function")
  kind          String   @default("business")
  description   String?
  definitionJson Json    @map("definition_json")
  status        String   @default("active")

  ownerId String? @map("owner_id")
  owner   User?   @relation("ToolOwner", fields: [ownerId], references: [id])

  assistantBindings AssistantTool[]
  toolCalls         ToolCall[]

  @@map("tools")
}

/// Join assistant ↔ tool for assigning multiple tools to each assistant.
model AssistantTool {
  id          String   @id @default(uuid())
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt      @map("updated_at")
  assistantId String   @map("assistant_id")
  toolId      String   @map("tool_id")
  enabled     Boolean  @default(true)

  assistant Assistant @relation(fields: [assistantId], references: [id], onDelete: Cascade)
  tool      Tool      @relation(fields: [toolId], references: [id], onDelete: Cascade)

  @@unique([assistantId, toolId], map: "assistant_tool_unique")
  @@map("assistant_tools")
}

/// Generic instruction block used to build Realtime `session.instructions`.
/// - `type` represents the logical block: "identity", "tone_guideline", etc.
/// - `lines` stores the list of textual instructions for that block.
///   NOTE: when moving to Postgres this can become `String[]` instead of `Json`.
model Instruction {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt      @map("updated_at")

  type   String   @unique
  label  String?
  lines  Json     @map("lines_json")
  status String   @default("active")

  ownerId String? @map("owner_id")
  owner   User?   @relation("InstructionOwner", fields: [ownerId], references: [id])

  assistantBindings AssistantInstruction[]

  @@map("instructions")
}

/// Join assistant ↔ instruction for assigning multiple instruction blocks
/// to each assistant, with per-assistant enable/disable and ordering.
model AssistantInstruction {
  id            String   @id @default(uuid())
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt      @map("updated_at")
  assistantId   String   @map("assistant_id")
  instructionId String   @map("instruction_id")
  enabled       Boolean  @default(true)
  sortOrder     Int      @default(0) @map("sort_order")

  assistant   Assistant   @relation(fields: [assistantId], references: [id], onDelete: Cascade)
  instruction Instruction @relation(fields: [instructionId], references: [id], onDelete: Cascade)

  @@unique([assistantId, instructionId], map: "assistant_instruction_unique")
  @@map("assistant_instructions")
}

/// Sanitization rule applied to assistant input/output text.
/// - `direction` controls where it is applied: "in", "out" or "both".
model SanitizationRule {
  id          String   @id @default(uuid())
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt      @map("updated_at")

  description String?
  pattern     String
  flags       String?  @default("g")
  replacement String   @default("")
  direction   String   @default("out")
  status      String   @default("active")

  ownerId String? @map("owner_id")
  owner   User?   @relation("SanitizationRuleOwner", fields: [ownerId], references: [id])

  assistantBindings AssistantSanitizationRule[]

  @@map("sanitization_rules")
}

/// Join assistant ↔ sanitization rule for assigning multiple rules
/// to each assistant, with per-assistant enable/disable and ordering.
model AssistantSanitizationRule {
  id          String   @id @default(uuid())
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt      @map("updated_at")
  assistantId String   @map("assistant_id")
  ruleId      String   @map("rule_id")
  enabled     Boolean  @default(true)
  sortOrder   Int      @default(0) @map("sort_order")

  assistant Assistant        @relation(fields: [assistantId], references: [id], onDelete: Cascade)
  rule      SanitizationRule @relation(fields: [ruleId], references: [id], onDelete: Cascade)

  @@unique([assistantId, ruleId], map: "assistant_sanitization_rule_unique")
  @@map("assistant_sanitization_rules")
}

/// Assistant instance configured by a user within a workspace
model Assistant {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt      @map("updated_at")

  name        String
  description String?
  slug        String   @unique
  status      AssistantStatus @default(active)

  workspaceId String  @map("workspace_id")
  ownerId     String  @map("owner_id")

  workspace Workspace        @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  owner     User             @relation("AssistantOwner", fields: [ownerId], references: [id])

  conversations   Conversation[]
  scopes          AssistantScopeDefinition[]
  knowledgeSource KnowledgeSource[]
  tools           AssistantTool[]
  instructions    AssistantInstruction[]
  sanitizationRules AssistantSanitizationRule[]

  @@map("assistants")
}

/// Scope definitions per assistant (support, star-wars, tech, etc.)
model AssistantScopeDefinition {
  id          String   @id @default(uuid())
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt      @map("updated_at")
  assistantId String   @map("assistant_id")
  name        String
  description String?
  keywords    Json?    @map("keywords_json")
  metadata    Json?    @map("metadata_json")

  assistant Assistant @relation(fields: [assistantId], references: [id], onDelete: Cascade)

  @@unique([assistantId, name], map: "assistant_scope_unique")
  @@map("assistant_scope_definitions")
}

/// Knowledge source configuration (Pinecone, JSON, etc.) per assistant
model KnowledgeSource {
  id          String   @id @default(uuid())
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt      @map("updated_at")
  assistantId String   @map("assistant_id")
  provider    String
  indexName   String?  @map("index_name")
  indexHost   String?  @map("index_host")
  namespace   String?  @map("namespace")
  metadata    Json?    @map("metadata_json")
  enabled     Boolean  @default(true)

  assistant Assistant @relation(fields: [assistantId], references: [id], onDelete: Cascade)

  @@map("knowledge_sources")
}

/// Conversation between a user and an assistant
model Conversation {
  id           String   @id @default(uuid())
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt      @map("updated_at")
  title        String
  mode         String   @default("unknown")
  currentScope String?  @map("current_scope")
  status       ConversationStatus @default(active)

  assistantId String  @map("assistant_id")
  userId      String? @map("user_id")

  assistant Assistant @relation(fields: [assistantId], references: [id], onDelete: Cascade)
  user      User?     @relation("ConversationUser", fields: [userId], references: [id])

  messages    Message[]
  toolCalls   ToolCall[]
  scopeEvents ConversationScopeEvent[]

  @@map("conversations")
}

/// Individual message turn within a conversation
model Message {
  id             String   @id @default(uuid())
  createdAt      DateTime @default(now()) @map("created_at")
  from           String
  text           String
  sequence       Int      @default(0)
  meta           Json?    @map("meta_json")
  audioUrl       String?  @map("audio_url")
  toolCallId     String?  @map("tool_call_id")
  conversationId String   @map("conversation_id")

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  toolCall     ToolCall?    @relation(fields: [toolCallId], references: [id])

  @@map("messages")
}

/// Tool invocation originating from the assistant within a conversation
model ToolCall {
  id             String    @id @default(uuid())
  createdAt      DateTime  @default(now()) @map("created_at")
  completedAt    DateTime? @map("completed_at")
  name           String
  status         String    @default("started")
  inputJson      Json      @map("input_json")
  resultJson     Json?     @map("result_json")
  error          String?

  conversationId String   @map("conversation_id")
  toolId         String?  @map("tool_id")

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  tool         Tool?        @relation(fields: [toolId], references: [id])
  messages     Message[]

  @@map("tool_calls")
}

/// Scope change events within a conversation (e.g. support → star-wars)
model ConversationScopeEvent {
  id             String   @id @default(uuid())
  createdAt      DateTime @default(now()) @map("created_at")
  fromScope      String?  @map("from_scope")
  toScope        String   @map("to_scope")
  reason         String?

  conversationId String       @map("conversation_id")
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@map("conversation_scope_events")
}

/// Authentication accounts per user (provider + providerAccountId)
model AuthAccount {
  id                String   @id @default(uuid())
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt      @map("updated_at")
  userId            String   @map("user_id")
  provider          String
  providerAccountId String   @map("provider_account_id")
  type              String   @default("oauth")
  status            AuthAccountStatus @default(active)

  user User @relation("UserAuthAccounts", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId], map: "provider_account_unique")
  @@map("auth_accounts")
}
